{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qdall'inglese Not only SQL; non solo SQL.\\E$"}
{"rule":"ARTICOLATA_SOSTANTIVO","sentence":"^\\QNella piattaforma è stato deciso di utilizzare un broker RabbitMQ\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q usando come protocollo di messaggistica l'Advanced message Queuing Protocol 0-9-1\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, per permettere alla API d'interagire con il microservizio del Mailer.\\E$"}
{"rule":"ARTICOLATA_SOSTANTIVO","sentence":"^\\QIn questa sezione verranno descritte le entità utilizzate per permettere alla API web di erogare i propri servizi.\\E$"}
{"rule":"ARTICOLATA_SOSTANTIVO","sentence":"^\\QLe policy definite all'interno della API web si basano sul protocollo di autorizzazione OAuth 2.0 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e sull'utilizzo di un modello di controllo sugli accessi basato sui ruoli dei singoli utenti.\\E$"}
{"rule":"ARTICOLATA_SOSTANTIVO","sentence":"^\\QL'implementazione presente all'interno della API web si basa su una coppia di credenziali: email e password.\\E$"}
{"rule":"ARTICOLATA_SOSTANTIVO","sentence":"^\\QL'erogazione dei servizi da parte della API web necessità di una memorizzazione permanente di dati, incapsulati all'interno di entità.\\E$"}
{"rule":"ST_01_005","sentence":"^\\QL'aggiunta di questo valore di salt rende la funzione di hash non deterministica ed evita così di generare valori di hash uguali per lo stesso input.\\E$"}
{"rule":"GR_04_002","sentence":"^\\QQueste permettono di aggiugnere un valore generato con una funzione di crittografia sicura che viene aggiunta al valore di ingresso della funzione di hash per andare a creare così dei message digest unici.\\E$"}
{"rule":"ST_01_005","sentence":"^\\QLe principali differenze sono che gli attacchi brute force utilizzano come input alla funzione di hash sequenze di caratteri casuali mentre gli attacchi dizionario utilizzano stringhe in lingua naturale ed entrambe richiedono una computazione runtime per calcolare il valore di hash.\\E$"}
{"rule":"ST_01_005","sentence":"^\\QLe hash table sono invece tabelle di valori di hash precedentemente calcolati: questo riduce molto i tempi per scoprire il valore di una password perché partendo da un database di valori di hash è possibile fare una associazione inversa e individuare l'input originale.\\E$"}
{"rule":"ST_01_005","sentence":"^\\QQueste permettono di aggiugnere all'input della funzione di hash un valore generato con una funzione di crittografia sicura andando così a creare dei message digest unici.\\E$"}
{"rule":"ST_01_005","sentence":"^\\QL'aggiunta di questo valore di salt rende la funzione di hash non deterministica ed evita così di generare message digest uguali per lo stesso input.\\E$"}
{"rule":"GR_04_002","sentence":"^\\QPer garantire una archiviazione sicura delle password è stato deciso di imporre regole sul formato della password per renderla 'poco' vulnerabile (lunga e con una sequenza confusa di numeri, lettere e simboli) e applicare una policy basata su funzioni di hash e di salt.\\E$"}
{"rule":"GR_04_002","sentence":"^\\QIn particolare avremo: 0em App Module: è il modulo principale che lega tutti i moduli fra loro e permette l'avvio della applicazione Auth Module: si occupa di tutti gli aspetti inerenti alla autenticazione e autorizzazione degli utenti User Module: si occupa della gestione delle informazioni degli utenti Demo Module: permette la registrazione a servizi in versione demo Ognuno di questi moduli è organizzato con una architettura a tre strati (vedi Figura \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) così definita: 0em Controller Layer: contiene gli elementi, detti Controllers, che permettono all'utente di interagire con i servizi offerti dalla piattaforma.\\E$"}
{"rule":"GR_04_002","sentence":"^\\QData Access Layer: contiene gli elementi, detti Models, che permettono di interagire con il database.\\E$"}
{"rule":"ER_01_001","sentence":"^\\QAnnunciato ufficialmente nel 2001 attravero il Manifesto Agile questo modello si contrappone al modello a cascata e\\E$"}
{"rule":"ER_01_001","sentence":"^\\QEmerge quindi in modo evidente la contrapposizione con i classici modelli di sviluppo come il modello a cascata.\\E$"}
{"rule":"MORFOLOGIK_RULE_IT_IT","sentence":"^\\QIn particolare è stato usato il metodo della containerizzazione per gestire l'installazione dei componenti nell'ambiente di produzione\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q./ RUN npm run build:all\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFROM node as dev WORKDIR /app COPY package*.json ./ RUN npm ci FROM dev as source COPY .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFROM node as prod ENV NODE_ENV production WORKDIR /app COPY –from=preprod /app/package*.json ./ COPY –from=preprod /app/node_modules ./node_modules COPY –from=source /app/dist ./dist USER node ENTRYPOINT [\"/bin/sh\"]\\E$"}
{"rule":"ST_03_001","sentence":"^\\QQuesto significa che ad ogni layer sarà associato un artefatto diverso rispetto al layer precedente e bisognerà quindi prestare attenzioni agli elementi effettivamente coinvolti nelle varie operazioni.\\E$"}
